// Generated by CoffeeScript 1.9.1
(function() {
  var Autocomplete, Autotrade, Calculator, Dchat, History, bit32, bnet, bnutil, construct, convert, help_message, init, intro, packets, socket, ui, xsha1,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.Stylist = (function() {
    function Stylist(name1, css) {
      var i;
      this.name = name1 != null ? name1 : "dynamic-stylist";
      this.css = css != null ? css : {};
      i = 0;
      while ($("#" + this.name + i.toString()).length !== 0) {
        i += 1;
      }
      this.name += i.toString();
      $("head").append(this.build());
    }

    Stylist.prototype.build = function() {
      var ik, iv, k, ref, s, v;
      s = "<style id='" + this.name + "'>\n";
      ref = this.css;
      for (k in ref) {
        v = ref[k];
        s += k + " {\n";
        for (ik in v) {
          iv = v[ik];
          s += "    " + ik;
          if (iv != null) {
            s += ": " + iv;
          }
          s += ";\n";
        }
        s += "}\n";
      }
      s += "</style>";
      return s;
    };

    Stylist.prototype.update = function() {
      return $("#" + this.name).replaceWith(this.build());
    };

    Stylist.prototype.remove = function() {
      return $("#" + this.name).remove();
    };

    return Stylist;

  })();

  ui = (function() {
    function ui() {}

    ui.Tab = (function() {
      function Tab(title1, prefix1, username1, id1, closeable1) {
        this.title = title1;
        this.prefix = prefix1;
        this.username = username1;
        this.id = id1;
        this.closeable = closeable1 != null ? closeable1 : true;
        this.html = [];
        this.input = "";
        this.unread = 0;
      }

      Tab.prototype.add = function(html) {
        return this.html.push(html);
      };

      Tab.prototype.set_title = function(title1) {
        this.title = title1;
        return $(this.id).html(this.title);
      };

      Tab.prototype.refresh_title = function() {
        if (this.unread !== 0) {
          return this.set_title("[" + this.unread + "] " + this.username);
        } else {
          return this.set_title("" + this.username);
        }
      };

      Tab.prototype.clear = function() {
        this.html = [];
        return this.unread = 0;
      };

      return Tab;

    })();

    ui.Tabs = (function() {
      function Tabs(tabs_id, chat_id, user_list_id, input_id, render_phrases, refresh_main_title) {
        var line_height;
        this.tabs_id = tabs_id;
        this.chat_id = chat_id;
        this.user_list_id = user_list_id;
        this.input_id = input_id;
        this.render_phrases = render_phrases;
        this.refresh_main_title = refresh_main_title;
        this.autosize = bind(this.autosize, this);
        this.remove = bind(this.remove, this);
        this.tabs_float_index = 0;
        this.stylist = new Stylist();
        this.user_list = new ui.UserList(this.user_list_id, this.render_phrases, this.input_id);
        this.tabs = [];
        this.add("", "", "main", false);
        this.main = this.active = this.tabs[0];
        line_height = $(this.main.id).outerHeight(true);
        this.stylist.css[this.tabs_id] = {
          "line-height": (line_height + 2) + "px"
        };
        this.stylist.update();
        this.autosize();
      }

      Tabs.prototype.get_tab = function(username) {
        var l, len, ref, tab;
        if (username == null) {
          username = "main";
        }
        ref = this.tabs;
        for (l = 0, len = ref.length; l < len; l++) {
          tab = ref[l];
          if (tab.username === username) {
            return tab;
          }
        }
      };

      Tabs.prototype.whisper = function(username, html, scroll_down) {
        var tab;
        if (scroll_down == null) {
          scroll_down = true;
        }
        tab = this.get_tab(username);
        if (tab != null) {
          tab.add(html);
          if (tab === this.active) {
            $(this.chat_id).append(html);
          } else if (tab !== this.main) {
            tab.unread += 1;
          }
          if (scroll_down) {
            $(this.chat_id).scrollTop($(this.chat_id)[0].scrollHeight);
          }
          if (tab !== this.main) {
            tab.refresh_title();
            this.refresh_main_title();
          }
          return;
        }
        this.add("", "/w " + username + " ", username);
        return this.whisper(username, html, scroll_down);
      };

      Tabs.prototype.echo = function(html, scroll_down) {
        if (scroll_down == null) {
          scroll_down = true;
        }
        return this.whisper("main", html, scroll_down);
      };

      Tabs.prototype.add = function(title, prefix, username, closeable) {
        var id, tab;
        if (closeable == null) {
          closeable = true;
        }
        while ($("#tab" + this.tabs_float_index.toString()).length !== 0) {
          this.tabs_float_index += 1;
        }
        id = "tab" + this.tabs_float_index.toString();
        tab = new ui.Tab(title, prefix, username, "#" + id, closeable);
        this.tabs.push(tab);
        $(this.tabs_id).append("<span id=" + id + "></span> ");
        $("#" + id).addClass("tab border color-border color-text").html(title);
        $("#" + id).on("mouseup", (function(_this) {
          return function(e) {
            switch (e.which) {
              case 1:
                _this.set_active(tab);
                break;
              case 2:
                _this.remove(tab);
            }
            return e.preventDefault();
          };
        })(this));
        return this.autosize();
      };

      Tabs.prototype.set_active = function(tab) {
        if (tab == null) {
          tab = this.main;
        }
        $(this.active.id).removeClass("color-active-tab-back color-active-tab-fore");
        $(tab.id).addClass("color-active-tab-back color-active-tab-fore");
        this.active.input = $(this.input_id).val();
        this.active = tab;
        $(this.input_id).val(this.active.input);
        $(this.chat_id).html(this.active.html.join(""));
        $(this.chat_id).scrollTop($(this.chat_id)[0].scrollHeight);
        this.active.unread = 0;
        this.active.refresh_title();
        this.refresh_main_title();
        return $(this.input_id).focus();
      };

      Tabs.prototype.remove = function(tab) {
        if (tab == null) {
          tab = this.active;
        }
        if (tab.closeable === true) {
          this.tabs = this.tabs.filter(function(t) {
            return t !== tab;
          });
          if (this.active === tab) {
            this.set_active(this.main);
          }
          $(tab.id).off("mouseup");
          $(tab.id).remove();
          return this.autosize();
        }
      };

      Tabs.prototype.autosize = function() {
        var height, id, l, len, ref;
        height = $(this.tabs_id).outerHeight(true) + $(this.chat_id).outerHeight(true) + $(this.input_id).outerHeight(true) - $(this.chat_id).innerHeight() + 30;
        ref = [this.chat_id, this.user_list_id];
        for (l = 0, len = ref.length; l < len; l++) {
          id = ref[l];
          this.stylist.css[id] = {
            "height": "calc(100% - " + height + "px)"
          };
        }
        return this.stylist.update();
      };

      Tabs.prototype.index = function(tab) {
        var i, l, ref;
        if (tab == null) {
          tab = this.active;
        }
        for (i = l = 0, ref = this.tabs.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          if (tab === this.tabs[i]) {
            return i;
          }
        }
      };

      Tabs.prototype.next = function() {
        if (this.tabs.length > 1) {
          return this.set_active(this.tabs[(this.index() + 1) % this.tabs.length]);
        }
      };

      Tabs.prototype.prev = function() {
        if (this.tabs.length > 1) {
          return this.set_active(this.tabs[(this.tabs.length + this.index() - 1) % this.tabs.length]);
        }
      };

      return Tabs;

    })();

    ui.UserList = (function() {
      function UserList(user_list_id, render_phrases, input_id) {
        this.user_list_id = user_list_id;
        this.render_phrases = render_phrases;
        this.input_id = input_id;
        this.clear();
      }

      UserList.prototype.add = function(username, nickname) {
        var html, id, msg, msgs;
        if (this.mem[username] != null) {
          return;
        }
        msgs = [["color-delimiter", "*"], ["color-user-list-account", username]];
        if (nickname !== "") {
          msgs.push(["color-user-list-nickname", " (" + nickname + ")"]);
        }
        msg = this.render_phrases.apply(this, msgs);
        this.mem[username] = this.internal_id;
        id = (this.user_list_id.substr(1)) + "-member-" + this.mem[username];
        html = "<div id='" + id + "' class='user-list-member'>" + msg + "</div>";
        if (nickname !== "") {
          $(this.user_list_id).append(html);
        } else {
          $(this.user_list_id).prepend(html);
        }
        $("#" + id).on("mouseup", (function(_this) {
          return function(e) {
            if (e.which === 1) {
              $(_this.input_id).val("/w *" + username + " ");
              $(_this.input_id).focus();
            }
            return e.preventDefault();
          };
        })(this));
        return this.internal_id = this.internal_id + 1;
      };

      UserList.prototype.remove = function(username) {
        if (this.mem[username] != null) {
          $(this.user_list_id + "-member-" + this.mem[username]).off("mouseup");
          $(this.user_list_id + "-member-" + this.mem[username]).remove();
          return delete this.mem[username];
        }
      };

      UserList.prototype.clear = function() {
        $(this.user_list_id).html("");
        this.internal_id = 0;
        return this.mem = {};
      };

      return UserList;

    })();

    return ui;

  })();

  bit32 = (function() {
    function bit32() {}

    bit32.make_signed = function(n) {
      return (n & 0xffffffff) << 0;
    };

    bit32.make_unsigned = function(n) {
      return (n & 0xffffffff) >>> 0;
    };

    bit32.shr = function(n, s) {
      if (s >= 32) {
        return 0;
      } else {
        return this.make_unsigned(n >>> s);
      }
    };

    bit32.shl = function(n, s) {
      if (s >= 32) {
        return 0;
      } else {
        return this.make_unsigned(n << s);
      }
    };

    bit32.ror = function(n, s) {
      return this.make_unsigned(this.shr(n, s % 32) | this.shl(n, 32 - (s % 32)));
    };

    bit32.rol = function(n, s) {
      return this.make_unsigned(this.shr(n, 32 - (s % 32)) | this.shl(n, s % 32));
    };

    return bit32;

  })();

  convert = (function() {
    function convert() {}

    convert.utf8_encode = function(s) {
      var bits_per_first, bytes, code, i, l, ref, sub;
      bytes = [];
      for (i = l = 0, ref = s.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        code = s.charCodeAt(i);
        if (code < 0x80) {
          bytes.push(code);
          continue;
        }
        bits_per_first = 6;
        sub = [];
        while (code > (bit32.shl(1, bits_per_first) - 1)) {
          sub.push(0x80 | (code & (bit32.shl(1, 6) - 1)));
          code = bit32.shr(code, 6);
          bits_per_first -= 1;
        }
        sub.push(code | (bit32.shl(0xff, bits_per_first + 1) & 0xff));
        bytes = bytes.concat(sub.reverse());
      }
      return bytes;
    };

    convert.utf8_decode = function(b) {
      var byte, char_codes, code, i, j, l, ref, shifts;
      char_codes = [];
      i = 0;
      while (i < b.length) {
        byte = b[i++];
        shifts = 0;
        while (byte & 0x80) {
          byte = bit32.shl(byte, 1) & 0xff;
          shifts += 1;
        }
        code = bit32.shr(byte, shifts);
        if (shifts !== 0) {
          for (j = l = 1, ref = shifts; 1 <= ref ? l < ref : l > ref; j = 1 <= ref ? ++l : --l) {
            code = bit32.shl(code, 6) | (b[i++] & (bit32.shl(1, 6) - 1));
          }
        }
        char_codes.push(code);
      }
      return String.fromCharCode.apply(String, char_codes);
    };

    convert.bin2str = function(bin) {
      return convert.utf8_decode(bin);
    };

    convert.str2bin = function(str) {
      return convert.utf8_encode(str);
    };

    convert.bin2hex = function(bin) {
      var sizer;
      sizer = function(s) {
        if (s.length === 1) {
          return "0" + s;
        } else {
          return s;
        }
      };
      return bin.map(function(x) {
        return sizer(x.toString(16));
      }).join(" ");
    };

    convert.hex2bin = function(hex) {
      return hex.split(" ").map(function(x) {
        return parseInt(x, 16);
      });
    };

    return convert;

  })();

  construct = (function() {
    function construct() {}

    construct.copy = function(obj, visited) {
      var c, k, l, len, len1, q, r, ref, v;
      if (visited == null) {
        visited = [];
      }
      if (typeof obj !== "object") {
        return obj;
      }
      for (l = 0, len = visited.length; l < len; l++) {
        ref = visited[l], r = ref[0], c = ref[1];
        if (r === obj) {
          return c;
        }
      }
      if (obj instanceof Array) {
        c = [];
        visited.push([obj, c]);
        for (q = 0, len1 = obj.length; q < len1; q++) {
          v = obj[q];
          c.push(this.copy(v, visited));
        }
      } else {
        c = {};
        visited.push([obj, c]);
        for (k in obj) {
          v = obj[k];
          c[k] = this.copy(v, visited);
        }
      }
      return c;
    };

    construct.linkify = function(obj, owner) {
      var k, l, len, v;
      if (owner == null) {
        owner = obj;
      }
      if (typeof obj === "object") {
        if (obj instanceof Array) {
          for (l = 0, len = obj.length; l < len; l++) {
            v = obj[l];
            this.linkify(v, owner);
          }
        } else {
          obj["_"] = owner;
          for (k in obj) {
            v = obj[k];
            if (v !== owner) {
              this.linkify(v, obj);
            }
          }
        }
      }
      return obj;
    };

    construct.DataIO = (function() {
      function DataIO(data1, shift) {
        this.data = data1 != null ? data1 : [];
        this.shift = shift != null ? shift : 0;
      }

      DataIO.prototype.read = function() {
        if (this.shift === this.data.length) {
          throw new Error("DataReader: end of data");
        }
        return this.data[this.shift++];
      };

      DataIO.prototype.tail = function() {
        return this.data.slice(this.shift);
      };

      DataIO.prototype.write = function(bytes) {
        var ref;
        (ref = this.data).push.apply(ref, bytes);
        return this.data;
      };

      return DataIO;

    })();

    construct.Base = (function() {
      function Base() {}

      Base.prototype.parse = function(data) {
        var ctx;
        ctx = {};
        ctx["_"] = ctx;
        return this.__parse(new construct.DataIO(data), ctx);
      };

      Base.prototype.build = function(data) {
        return this.__build(data, new construct.DataIO());
      };

      return Base;

    })();

    construct._BaseInt = (function(superClass) {
      extend(_BaseInt, superClass);

      function _BaseInt(name1, size1, signed, endian) {
        var ref, ref1;
        this.name = name1;
        this.size = size1;
        this.signed = signed;
        this.endian = endian;
        if (typeof this.size !== "number" || this.size < 1) {
          throw new Error("BaseInt (name = '" + this.name + "'): bad size ('" + this.size + "')");
        }
        if ((ref = this.signed) !== "signed" && ref !== "unsigned") {
          throw new Error("BaseInt (name = '" + this.name + "'): bad sign ('" + this.signed + "')");
        }
        if ((ref1 = this.endian) !== "little" && ref1 !== "big") {
          throw new Error("BaseInt (name = '" + this.name + "'): bad endian ('" + this.endian + "')");
        }
      }

      _BaseInt.signification = function(num, size) {
        if (num & Math.pow(2, size * 8 - 1)) {
          return bit32.make_unsigned(num) - Math.pow(2, size * 8);
        } else {
          return bit32.make_unsigned(num);
        }
      };

      _BaseInt.prototype.__parse = function(io) {
        var data, head, i, l, num, ref, ref1, ref2, ref3, ref4, step, tail;
        data = (function() {
          var l, ref, results;
          results = [];
          for (i = l = 1, ref = this.size; 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
            results.push(io.read());
          }
          return results;
        }).call(this);
        if (this.endian === "big") {
          ref = [0, this.size - 1, 1], head = ref[0], tail = ref[1], step = ref[2];
        } else if (this.endian === "little") {
          ref1 = [this.size - 1, 0, -1], head = ref1[0], tail = ref1[1], step = ref1[2];
        }
        num = 0;
        for (i = l = ref2 = head, ref3 = tail, ref4 = step; ref4 > 0 ? l <= ref3 : l >= ref3; i = l += ref4) {
          if (data[i] != null) {
            num = bit32.make_unsigned(bit32.shl(num, 8) | data[i]);
          } else {
            throw new Error("BaseInt (name = '" + this.name + "'), bad data");
          }
        }
        if (this.signed === "signed") {
          num = _BaseInt.signification(num, this.size);
        }
        return num;
      };

      _BaseInt.prototype.__build = function(num, io) {
        var data, i, l, ref;
        data = [];
        num = bit32.make_unsigned(num);
        for (i = l = 1, ref = this.size; 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
          data.push(num & 0xff);
          num = bit32.shr(num, 8);
        }
        if (this.endian === "big") {
          data.reverse();
        }
        return io.write(data);
      };

      return _BaseInt;

    })(construct.Base);

    construct._CString = (function(superClass) {
      extend(_CString, superClass);

      function _CString(name1) {
        this.name = name1;
      }

      _CString.prototype.__parse = function(io) {
        var ch, data, error;
        data = [];
        try {
          while ((ch = io.read()) !== 0) {
            data.push(ch);
          }
          return convert.bin2str(data);
        } catch (_error) {
          error = _error;
          throw new Error("CString, unexpected end of data");
        }
      };

      _CString.prototype.__build = function(string, io) {
        io.write(convert.str2bin(string));
        return io.write([0]);
      };

      return _CString;

    })(construct.Base);

    construct._Struct = (function(superClass) {
      extend(_Struct, superClass);

      function _Struct() {
        var name1, objects;
        name1 = arguments[0], objects = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        this.name = name1;
        this.objects = objects;
      }

      _Struct.prototype.__parse = function(io, ctx) {
        var l, len, object, parsed, ref;
        ref = this.objects;
        for (l = 0, len = ref.length; l < len; l++) {
          object = ref[l];
          parsed = object.__parse(io, {
            "_": ctx
          });
          if (object.name != null) {
            ctx[object.name] = parsed;
          }
        }
        return ctx;
      };

      _Struct.prototype.__build = function(ctx, io) {
        var l, len, object, ref;
        ref = this.objects;
        for (l = 0, len = ref.length; l < len; l++) {
          object = ref[l];
          if ((object.name != null) && (ctx[object.name] != null)) {
            object.__build(ctx[object.name], io);
          } else {
            object.__build(ctx, io);
          }
        }
        return io.data;
      };

      return _Struct;

    })(construct.Base);

    construct._Enum = (function(superClass) {
      extend(_Enum, superClass);

      function _Enum(object1, values) {
        this.object = object1;
        this.values = values;
        this.name = this.object.name;
      }

      _Enum.prototype.__parse = function(io) {
        var parsed;
        parsed = this.object.__parse(io);
        if (this.values[parsed] != null) {
          return this.values[parsed];
        } else {
          throw new Error("Enum: value not in list (" + parsed + ")");
        }
      };

      _Enum.prototype.__build = function(value, io) {
        var k, ref, v;
        ref = this.values;
        for (k in ref) {
          v = ref[k];
          if (value === v) {
            return this.object.__build(k, io);
          }
        }
        throw new Error("Enum: value not in list (" + ctx[this.name] + ")");
      };

      return _Enum;

    })(construct.Base);

    construct._Const = (function(superClass) {
      extend(_Const, superClass);

      function _Const(object1, value1) {
        this.object = object1;
        this.value = value1;
        this.name = this.object.name;
      }

      _Const.prototype.__parse = function(io) {
        var parsed;
        parsed = this.object.__parse(io);
        if (parsed === this.value) {
          return this.value;
        } else {
          throw new Error("Const: expect (" + this.value + "), but got (" + parsed + ")");
        }
      };

      _Const.prototype.__build = function(nothing, io) {
        return this.object.__build(this.value, io);
      };

      return _Const;

    })(construct.Base);

    construct._Switch = (function(superClass) {
      extend(_Switch, superClass);

      function _Switch(f, objects) {
        this.f = f;
        this.objects = objects;
      }

      _Switch.prototype.__parse = function(io, ctx) {
        var object;
        ctx = ctx["_"];
        object = this.objects[this.f(ctx)] || this.objects["default"];
        if (object != null) {
          if ((object.name != null) && (ctx[object.name] != null)) {
            return object.__parse(io, ctx[object.name]);
          } else {
            return object.__parse(io, ctx);
          }
        } else {
          throw new Error("Switch: there is no (" + (this.f(ctx)) + ") key or 'default'");
        }
      };

      _Switch.prototype.__build = function(ctx, io) {
        var object;
        object = this.objects[this.f(ctx)] || this.objects["default"];
        if (object != null) {
          if ((object.name != null) && (ctx[object.name] != null)) {
            return object.__build(ctx[object.name], io);
          } else {
            return object.__build(ctx, io);
          }
        } else {
          throw new Error("Switch: there is no (" + (this.f(ctx)) + ") key or 'default'");
        }
      };

      return _Switch;

    })(construct.Base);

    construct._Pass = (function(superClass) {
      extend(_Pass, superClass);

      function _Pass() {
        return _Pass.__super__.constructor.apply(this, arguments);
      }

      _Pass.prototype.__parse = function(io, ctx) {
        return ctx;
      };

      _Pass.prototype.__build = function(ctx, io) {
        return io.data;
      };

      return _Pass;

    })(construct.Base);

    construct._OptionalGreedyRange = (function(superClass) {
      extend(_OptionalGreedyRange, superClass);

      function _OptionalGreedyRange(object1) {
        this.object = object1;
        this.name = this.object.name;
      }

      _OptionalGreedyRange.prototype.__parse = function(io, ctx) {
        var ctxs, error, io_position;
        ctxs = [];
        io_position = io.shift;
        try {
          while (true) {
            io_position = io.shift;
            ctxs.push(this.object.__parse(io, construct.copy(ctx)));
            if (ctx["_"] != null) {
              ctxs[ctxs.length - 1]["_"] = ctx["_"];
            }
          }
        } catch (_error) {
          error = _error;
          io.shift = io_position;
        }
        return ctxs;
      };

      _OptionalGreedyRange.prototype.__build = function(ctxs, io) {
        var ctx, l, len;
        for (l = 0, len = ctxs.length; l < len; l++) {
          ctx = ctxs[l];
          this.object.__build(ctx, io);
        }
        return io.data;
      };

      return _OptionalGreedyRange;

    })(construct.Base);

    construct._Array = (function(superClass) {
      extend(_Array, superClass);

      function _Array(cnt, object1) {
        this.object = object1;
        this.name = this.object.name;
        if (typeof cnt === "number") {
          this.count = function() {
            return cnt;
          };
        } else {
          this.count = cnt;
        }
      }

      _Array.prototype.__parse = function(io, ctx) {
        var ctxs, i, l, ref;
        ctxs = [];
        for (i = l = 1, ref = this.count(ctx); 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
          ctxs.push(this.object.__parse(io, construct.copy(ctx)));
          if (ctx["_"] != null) {
            ctxs[ctxs.length - 1]["_"] = ctx["_"];
          }
        }
        return ctxs;
      };

      _Array.prototype.__build = function(ctxs, io) {
        var ctx, l, len;
        if (ctxs.length !== this.count(ctxs[0])) {
          throw new Error("Array: count of objects (" + ctxs.length + ") doesn't matches " + (this.count()));
        }
        for (l = 0, len = ctxs.length; l < len; l++) {
          ctx = ctxs[l];
          this.object.__build(ctx, io);
        }
        return io.data;
      };

      return _Array;

    })(construct.Base);

    construct._Adapter = (function(superClass) {
      extend(_Adapter, superClass);

      function _Adapter(object1, parser, builder) {
        this.object = object1;
        this.parser = parser;
        this.builder = builder;
      }

      _Adapter.prototype.__parse = function(io, ctx) {
        return this.parser(this.object.__parse(io, ctx), ctx);
      };

      _Adapter.prototype.__build = function(ctx, io) {
        return this.object.build(this.builder(ctx), io);
      };

      return _Adapter;

    })(construct.Base);

    construct._Optional = (function(superClass) {
      extend(_Optional, superClass);

      function _Optional(object1) {
        this.object = object1;
        this.name = this.object.name;
      }

      _Optional.prototype.__parse = function(io, ctx) {
        var error, io_position, ret;
        io_position = io.shift;
        try {
          ret = this.object.__parse(io, construct.copy(ctx));
          if (ctx["_"] != null) {
            ret["_"] = ctx["_"];
          }
          return ret;
        } catch (_error) {
          error = _error;
          io.shift = io_position;
          return ctx;
        }
      };

      _Optional.prototype.__build = function(ctx, io) {
        var error, ios;
        ios = construct.copy(io);
        try {
          return this.object.__build(io, ctx);
        } catch (_error) {
          error = _error;
          return io.data = ios.data;
        }
      };

      return _Optional;

    })(construct.Base);

    construct.BaseInt = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._BaseInt, args, function(){});
    };

    construct.CString = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._CString, args, function(){});
    };

    construct.Struct = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Struct, args, function(){});
    };

    construct.Enum = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Enum, args, function(){});
    };

    construct.Const = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Const, args, function(){});
    };

    construct.Switch = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Switch, args, function(){});
    };

    construct.Pass = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Pass, args, function(){});
    };

    construct.OptionalGreedyRange = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._OptionalGreedyRange, args, function(){});
    };

    construct.Array = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Array, args, function(){});
    };

    construct.Adapter = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Adapter, args, function(){});
    };

    construct.Optional = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this._Optional, args, function(){});
    };

    construct.EmbedStruct = function() {
      var objecsts;
      objecsts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.Struct.apply(this, [null].concat(slice.call(objecsts)));
    };

    construct.Tail = function(name) {
      if (name == null) {
        name = "tail";
      }
      return this.OptionalGreedyRange(this.ULInt8(name));
    };

    construct.Bytes = function(name, count) {
      return this.Array(count, this.ULInt8(name));
    };

    construct.ULInt8 = function(name) {
      return this.BaseInt(name, 1, "unsigned", "little");
    };

    construct.ULInt16 = function(name) {
      return this.BaseInt(name, 2, "unsigned", "little");
    };

    construct.ULInt32 = function(name) {
      return this.BaseInt(name, 4, "unsigned", "little");
    };

    construct.UBInt8 = function(name) {
      return this.BaseInt(name, 1, "unsigned", "big");
    };

    construct.UBInt16 = function(name) {
      return this.BaseInt(name, 2, "unsigned", "big");
    };

    construct.UBInt32 = function(name) {
      return this.BaseInt(name, 4, "unsigned", "big");
    };

    construct.SLInt8 = function(name) {
      return this.BaseInt(name, 1, "signed", "little");
    };

    construct.SLInt16 = function(name) {
      return this.BaseInt(name, 2, "signed", "little");
    };

    construct.SLInt32 = function(name) {
      return this.BaseInt(name, 4, "signed", "little");
    };

    construct.SBInt8 = function(name) {
      return this.BaseInt(name, 1, "signed", "big");
    };

    construct.SBInt16 = function(name) {
      return this.BaseInt(name, 2, "signed", "big");
    };

    construct.SBInt32 = function(name) {
      return this.BaseInt(name, 4, "signed", "big");
    };

    return construct;

  })();

  xsha1 = (function() {
    function xsha1() {}

    xsha1.bsha1 = function(data) {
      return this.pack.apply(this, this.calc_hash_buffer(data));
    };

    xsha1.pack = function() {
      var arg, args, i, l, len, q, ret;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ret = [];
      for (l = 0, len = args.length; l < len; l++) {
        arg = args[l];
        for (i = q = 0; q <= 3; i = ++q) {
          ret.push(arg & 0xff);
          arg = bit32.shr(arg, 8);
        }
      }
      return ret;
    };

    xsha1.insert_byte = function(buf, loc, b) {
      var the_byte, the_int;
      the_int = Math.floor(loc / 4);
      the_byte = loc % 4;
      return buf[the_int] = (buf[the_int] & (bit32.shl(0xFF, 8 * the_byte) ^ 0xFFFFFFFF)) | bit32.shl(b, 8 * the_byte);
    };

    xsha1.calc_hash_buffer = function(hash_data) {
      var hash_buffer, i, j, l, sub_len;
      hash_buffer = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
      for (i = l = 1; l <= 16; i = ++l) {
        hash_buffer.push(0);
      }
      i = 0;
      while (i < hash_data.length) {
        sub_len = hash_data.length - i;
        if (sub_len > 0x40) {
          sub_len = 0x40;
        }
        j = 0;
        while (j < sub_len) {
          this.insert_byte(hash_buffer, j + 20, hash_data[j + i]);
          j += 1;
        }
        if (sub_len < 0x40) {
          j = sub_len;
          while (j < 0x40) {
            this.insert_byte(hash_buffer, j + 20, 0);
            j += 1;
          }
        }
        this.do_hash(hash_buffer);
        i += 0x40;
      }
      return hash_buffer.slice(0, 5);
    };

    xsha1.do_hash = function(hash_buffer) {
      var a, b, buf, c, d, dw, e, i, l, p, q, ref, results;
      buf = [];
      for (i = l = 1; l <= 80; i = ++l) {
        buf.push(0);
      }
      i = 0;
      while (i < 0x10) {
        buf[i] = hash_buffer[i + 5];
        i += 1;
      }
      while (i < 0x50) {
        dw = buf[i - 0x3] ^ buf[i - 0x8] ^ buf[i - 0x10] ^ buf[i - 0xE];
        buf[i] = bit32.rol(1, dw & 0x1f);
        i += 1;
      }
      ref = hash_buffer.slice(0, 5).map(bit32.make_unsigned), a = ref[0], b = ref[1], c = ref[2], d = ref[3], e = ref[4];
      p = 0;
      while (p < 20) {
        dw = bit32.rol(a, 5) + bit32.make_unsigned((~b & d) | (c & b)) + e + buf[p] + 0x5a827999;
        dw = bit32.make_unsigned(dw);
        e = d;
        d = c;
        c = bit32.make_unsigned(bit32.rol(b, 0x1E));
        b = a;
        a = dw;
        p += 1;
        i += 1;
      }
      while (p < 40) {
        dw = bit32.make_unsigned(d ^ c ^ b) + e + bit32.rol(a, 5) + buf[p] + 0x6ED9EBA1;
        dw = bit32.make_unsigned(dw);
        e = d;
        d = c;
        c = bit32.make_unsigned(bit32.rol(b, 0x1E));
        b = a;
        a = dw;
        p += 1;
      }
      while (p < 60) {
        dw = bit32.make_unsigned((c & b) | (d & c) | (d & b)) + e + bit32.rol(a, 5) + buf[p] - 0x70E44324;
        dw = bit32.make_unsigned(dw);
        e = d;
        d = c;
        c = bit32.make_unsigned(bit32.rol(b, 0x1E));
        b = a;
        a = dw;
        p += 1;
      }
      while (p < 80) {
        dw = bit32.rol(a, 5) + e + bit32.make_unsigned(d ^ c ^ b) + buf[p] - 0x359D3E2A;
        dw = bit32.make_unsigned(dw);
        e = d;
        d = c;
        c = bit32.make_unsigned(bit32.rol(b, 0x1E));
        b = a;
        a = dw;
        p += 1;
      }
      results = [];
      for (i = q = 0; q <= 4; i = ++q) {
        results.push(hash_buffer[i] = bit32.make_unsigned(hash_buffer[i] + [a, b, c, d, e][i]));
      }
      return results;
    };

    return xsha1;

  })();

  bnutil = (function() {
    function bnutil() {}

    bnutil.alpha_map = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x01, 0xFF, 0x02, 0x03, 0x04, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0x0F, 0x10, 0xFF, 0x11, 0xFF, 0x12, 0xFF, 0x13, 0xFF, 0x14, 0x15, 0x16, 0xFF, 0x17, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0x0F, 0x10, 0xFF, 0x11, 0xFF, 0x12, 0xFF, 0x13, 0xFF, 0x14, 0x15, 0x16, 0xFF, 0x17, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF];

    bnutil.hash_d2key = function(cdkey, client_token, server_token) {
      var checksum, hash_data, i, l, m_key, n, public_value, q, ref, ref1, ref2, ref3, t, v2, y;
      checksum = 0;
      m_key = [];
      for (i = l = 0, ref = cdkey.length; l < ref; i = l += 2) {
        n = bnutil.alpha_map[cdkey.charCodeAt(i)] * 24 + bnutil.alpha_map[cdkey.charCodeAt(i + 1)];
        if (n >= 0x100) {
          n -= 0x100;
          checksum = bit32.make_unsigned(checksum | bit32.shl(1, bit32.shr(i, 1)));
        }
        m_key[i] = bit32.make_unsigned(bit32.shr(n, 4) & 0xf).toString(16).toUpperCase();
        m_key[i + 1] = bit32.make_unsigned(n & 0xf).toString(16).toUpperCase();
      }
      if (m_key.reduce((function(v, ch) {
        return (v + (parseInt(ch, 16) ^ (v * 2))) & 0xff;
      }), 3) !== checksum) {
        return;
      }
      for (i = q = ref1 = cdkey.length - 1; q >= 0; i = q += -1) {
        n = (i - 9) & 0xf;
        ref2 = [m_key[n], m_key[i]], m_key[i] = ref2[0], m_key[n] = ref2[1];
      }
      v2 = 0x13AC9741;
      for (i = y = ref3 = cdkey.length - 1; y >= 0; i = y += -1) {
        t = parseInt(m_key[i], 16);
        if (t <= 7) {
          m_key[i] = String.fromCharCode((v2 & 7) ^ m_key[i].charCodeAt(0));
          v2 = bit32.shr(v2, 3);
        } else if (t < 10) {
          m_key[i] = String.fromCharCode((i & 1) ^ m_key[i].charCodeAt(0));
        }
      }
      m_key = m_key.join("");
      public_value = parseInt(m_key.slice(2, 8), 16);
      hash_data = xsha1.pack(client_token, server_token, parseInt(m_key.slice(0, 2), 16), public_value, 0, parseInt(m_key.slice(8, 16), 16));
      return [public_value, xsha1.bsha1(hash_data)];
    };

    bnutil.sub_double_hash = function(client_token, server_token, hashpass) {
      return xsha1.bsha1(xsha1.pack(client_token, server_token).concat(hashpass));
    };

    return bnutil;

  })();

  packets = (function() {
    function packets() {}

    packets._spacket = construct.Struct(null, construct.Const(construct.ULInt8(null), 0xff), construct.Enum(construct.ULInt8("packet_id"), {
      0x50: "SID_AUTH_INFO",
      0x25: "SID_PING",
      0x51: "SID_AUTH_CHECK",
      0x3a: "SID_LOGONRESPONSE2",
      0x0a: "SID_ENTERCHAT",
      0x0b: "SID_GETCHANNELLIST",
      0x0c: "SID_JOINCHANNEL",
      0x0e: "SID_CHATCOMMAND"
    }), construct.ULInt16("length"), construct.Switch(function(ctx) {
      return ctx.packet_id;
    }, {
      "SID_AUTH_INFO": construct.EmbedStruct(construct.ULInt32("protocol_id"), construct.Bytes("platform_id", 4), construct.Bytes("product_id", 4), construct.ULInt32("version_byte"), construct.Bytes("product_language", 4), construct.Bytes("local_ip", 4), construct.SLInt32("time_zone"), construct.ULInt32("locale_id"), construct.ULInt32("language_id"), construct.CString("country_abreviation"), construct.CString("country")),
      "SID_PING": construct.EmbedStruct(construct.ULInt32("value")),
      "SID_AUTH_CHECK": construct.EmbedStruct(construct.ULInt32("client_token"), construct.ULInt32("exe_version"), construct.ULInt32("exe_hash"), construct.ULInt32("number_of_cd_keys"), construct.ULInt32("spawn_cd_key"), construct.Array(function(ctx) {
        return ctx["_"].number_of_cd_keys;
      }, construct.Struct("cd_keys", construct.ULInt32("key_length"), construct.ULInt32("cd_key_product"), construct.ULInt32("cd_key_public"), construct.Const(construct.ULInt32(null), 0), construct.Bytes("hash", 5 * 4))), construct.CString("exe_info"), construct.CString("cd_key_owner")),
      "SID_LOGONRESPONSE2": construct.EmbedStruct(construct.ULInt32("client_token"), construct.ULInt32("server_token"), construct.Bytes("hash", 5 * 4), construct.CString("username")),
      "SID_ENTERCHAT": construct.EmbedStruct(construct.CString("username"), construct.CString("statstring")),
      "SID_GETCHANNELLIST": construct.EmbedStruct(construct.Bytes("product_id", 4)),
      "SID_JOINCHANNEL": construct.EmbedStruct(construct.ULInt32("unknown"), construct.CString("channel_name")),
      "SID_CHATCOMMAND": construct.EmbedStruct(construct.CString("text"))
    }));

    packets.spacket = construct.Adapter(packets._spacket, function(ctx) {
      return ctx;
    }, function(ctx) {
      ctx.length = 0;
      ctx.length = packets._spacket.build(construct.copy(ctx)).length;
      return ctx;
    });

    packets.rpacket = construct.Struct("rpackets", construct.Const(construct.ULInt8(null), 0xff), construct.Enum(construct.ULInt8("packet_id"), {
      0x25: "SID_PING",
      0x50: "SID_AUTH_INFO",
      0x51: "SID_AUTH_CHECK",
      0x3a: "SID_LOGONRESPONSE2",
      0x0a: "SID_ENTERCHAT",
      0x0b: "SID_GETCHANNELLIST",
      0x0f: "SID_CHATEVENT"
    }), construct.ULInt16("length"), construct.Switch(function(ctx) {
      return ctx.packet_id;
    }, {
      "SID_PING": construct.EmbedStruct(construct.ULInt32("value")),
      "SID_AUTH_INFO": construct.EmbedStruct(construct.ULInt32("logon_type"), construct.ULInt32("server_token"), construct.ULInt32("udp_value"), construct.Bytes("file_time", 8), construct.CString("file_name"), construct.CString("seed_values")),
      "SID_AUTH_CHECK": construct.EmbedStruct(construct.ULInt32("result"), construct.CString("info")),
      "SID_LOGONRESPONSE2": construct.EmbedStruct(construct.ULInt32("result"), construct.Optional(construct.CString("info"))),
      "SID_ENTERCHAT": construct.EmbedStruct(construct.CString("unique_name"), construct.CString("statstring"), construct.CString("account_name")),
      "SID_GETCHANNELLIST": construct.EmbedStruct(construct.OptionalGreedyRange(construct.CString("channels"))),
      "SID_CHATEVENT": construct.EmbedStruct(construct.Enum(construct.ULInt32("event_id"), {
        0x01: "ID_USER",
        0x02: "ID_JOIN",
        0x03: "ID_LEAVE",
        0x04: "ID_WHISPER",
        0x05: "ID_TALK",
        0x06: "ID_BROADCAST",
        0x07: "ID_CHANNEL",
        0x09: "ID_USERFLAGS",
        0x0a: "ID_WHISPERSENT",
        0x0d: "ID_CHANNELFULL",
        0x0e: "ID_CHANNELDOESNOTEXIST",
        0x0f: "ID_CHANNELRESTRICTED",
        0x12: "ID_INFO",
        0x13: "ID_ERROR",
        0x17: "ID_EMOTE",
        0x18: "ID_SYSTEMBLUE",
        0x19: "ID_SYSTEMRED"
      }), construct.ULInt32("user_flags"), construct.ULInt32("ping"), construct.Bytes("ip_address", 4), construct.ULInt32("account_number"), construct.ULInt32("registration_authority"), construct.CString("username"), construct.CString("text"))
    }));

    packets.rpackets = construct.Struct(null, construct.OptionalGreedyRange(packets.rpacket), construct.Tail());

    return packets;

  })();

  bnet = (function() {
    function bnet() {}

    bnet.Bnet = (function() {
      function Bnet(host, port1, connect, _send, login_error, chat_event) {
        this.host = host;
        this.port = port1;
        this.connect = connect;
        this.login_error = login_error != null ? login_error : (function() {});
        this.chat_event = chat_event != null ? chat_event : (function() {});
        this.on_packet = bind(this.on_packet, this);
        this.login = bind(this.login, this);
        this.send = function(data) {
          return _send(convert.bin2hex(data));
        };
        this.lock = false;
      }

      Bnet.prototype.login = function(username1, password, hashed) {
        this.username = username1;
        if (hashed) {
          this.hashpass = password;
        } else {
          this.hashpass = xsha1.bsha1(convert.str2bin(password));
        }
        this.head = [];
        if (!this.connect(this.host, this.port)) {
          this.login_error("Connecting to server");
          return;
        }
        this.send([1]);
        return this.send(packets.spacket.build(construct.linkify({
          packet_id: "SID_AUTH_INFO",
          protocol_id: 0,
          platform_id: convert.str2bin('68XI'),
          product_id: convert.str2bin('PX2D'),
          version_byte: 13,
          product_language: convert.str2bin('SUne'),
          local_ip: [192, 168, 0, 100],
          time_zone: -300,
          locale_id: 1049,
          language_id: 1049,
          country_abreviation: 'RUS',
          country: 'Russia'
        })));
      };

      Bnet.prototype.say = function(msg) {
        return this.send(packets.spacket.build(construct.linkify({
          packet_id: "SID_CHATCOMMAND",
          text: msg
        })));
      };

      Bnet.prototype.on_packet = function(msg) {
        var clhash, clpub, l, len, lodhash, lodpub, pack, ref, ref1, ref2, unparsed, w;
        unparsed = packets.rpackets.parse(this.head.concat(convert.hex2bin(msg)));
        this.head = unparsed.tail;
        ref = unparsed.rpackets;
        for (l = 0, len = ref.length; l < len; l++) {
          pack = ref[l];
          switch (pack.packet_id) {
            case "SID_PING":
              this.send(packets.spacket.build(pack));
              break;
            case "SID_AUTH_INFO":
              this.client_token = 666;
              this.server_token = pack.server_token;
              ref1 = bnutil.hash_d2key("DPTGEGHRPH4EB7EV", this.client_token, this.server_token), clpub = ref1[0], clhash = ref1[1];
              ref2 = bnutil.hash_d2key("KFE6H7RPTRTHDEJE", this.client_token, this.server_token), lodpub = ref2[0], lodhash = ref2[1];
              w = new Worker("check-revision-background.js");
              w.onmessage = (function(_this) {
                return function(event) {
                  var info;
                  info = JSON.parse(event.data);
                  if (info.done) {
                    _this.send(packets.spacket.build(construct.linkify({
                      packet_id: "SID_AUTH_CHECK",
                      client_token: _this.client_token,
                      exe_version: 0x01000d00,
                      exe_hash: info.result,
                      number_of_cd_keys: 2,
                      spawn_cd_key: 0,
                      cd_keys: [
                        {
                          key_length: 16,
                          cd_key_product: 6,
                          cd_key_public: clpub,
                          hash: clhash
                        }, {
                          key_length: 16,
                          cd_key_product: 12,
                          cd_key_public: lodpub,
                          hash: lodhash
                        }
                      ],
                      exe_info: "Game.exe 10/18/11 20:48:14 65536",
                      cd_key_owner: "yoba"
                    })));
                    return w.terminate();
                  }
                };
              })(this);
              w.postMessage(JSON.stringify([pack.seed_values, pack.file_name]));

              /*
              @send(
                  packets.spacket.build(
                      construct.linkify({
                          packet_id:"SID_AUTH_CHECK",
                          client_token:@client_token,
                          exe_version:0x01000d00,
                          exe_hash:bnutil.check_revision(
                              pack.seed_values,
                              pack.file_name
                          ),
                          number_of_cd_keys:2,
                          spawn_cd_key:0,
                          cd_keys:[
                              {
                                  key_length:16,
                                  cd_key_product:6,
                                  cd_key_public:clpub,
                                  hash:clhash,
                              },
                              {
                                  key_length:16,
                                  cd_key_product:12,
                                  cd_key_public:lodpub,
                                  hash:lodhash,
                              },
                          ],
                          exe_info:"Game.exe 10/18/11 20:48:14 65536",
                          cd_key_owner:"yoba",
                      })
                  )
              )
               */
              break;
            case "SID_AUTH_CHECK":
              if (pack.result !== 0) {
                this.login_error(pack.packet_id, pack.result);
              } else {
                this.send(packets.spacket.build(construct.linkify({
                  packet_id: "SID_LOGONRESPONSE2",
                  client_token: this.client_token,
                  server_token: this.server_token,
                  hash: bnutil.sub_double_hash(this.client_token, this.server_token, this.hashpass),
                  username: this.username
                })));
              }
              break;
            case "SID_LOGONRESPONSE2":
              if (pack.result !== 0) {
                this.login_error(pack.packet_id, pack.result);
              } else {
                this.send(packets.spacket.build(construct.linkify({
                  packet_id: "SID_ENTERCHAT",
                  username: this.username,
                  statstring: ""
                })));
              }
              break;
            case "SID_ENTERCHAT":
              this.send(packets.spacket.build(construct.linkify({
                packet_id: "SID_JOINCHANNEL",
                unknown: 5,
                channel_name: "Diablo II"
              })));
              break;
            case "SID_CHATEVENT":
              this.chat_event(pack);
              break;
            default:
              console.log(pack);
          }
        }
      };

      return Bnet;

    })();

    return bnet;

  })();

  socket = (function() {
    function socket() {}

    socket.WebSocketBridge = (function() {
      function WebSocketBridge(on_data, on_disconnect, on_error) {
        this.on_data = on_data;
        this.on_disconnect = on_disconnect;
        this.on_error = on_error;
        this.receive = bind(this.receive, this);
        this.send = bind(this.send, this);
        this.disconnect = bind(this.disconnect, this);
        this.connect = bind(this.connect, this);
        this.reset();
      }

      WebSocketBridge.prototype.reset = function() {
        this.websocket_ok = false;
        this.socket = new WebSocket("ws://" + location.host + "/bin");
        this.socket.onmessage = this.receive;
        this.socket.onopen = (function(_this) {
          return function() {
            return _this.websocket_ok = true;
          };
        })(this);
        this.socket.onclose = (function(_this) {
          return function() {
            _this.websocket_ok = false;
            return typeof _this.on_disconnect === "function" ? _this.on_disconnect() : void 0;
          };
        })(this);
        return this.socket.onerror = (function(_this) {
          return function(e) {
            _this.websocket_ok = false;
            if (typeof _this.on_error === "function") {
              _this.on_error(e.message);
            }
            return typeof _this.on_disconnect === "function" ? _this.on_disconnect() : void 0;
          };
        })(this);
      };

      WebSocketBridge.prototype.connect = function(address, port) {
        this.socket.send(JSON.stringify({
          "type": "CONNECT",
          "address": address,
          "port": port
        }));
        return true;
      };

      WebSocketBridge.prototype.disconnect = function() {
        this.socket.send(JSON.stringify({
          "type": "DISCONNECT"
        }));
        return true;
      };

      WebSocketBridge.prototype.send = function(d) {
        this.socket.send(JSON.stringify({
          "type": "DATA",
          "data": d
        }));
        return true;
      };

      WebSocketBridge.prototype.receive = function(e) {
        var o;
        o = JSON.parse(e.data);
        switch (o["type"]) {
          case "DATA":
            return typeof this.on_data === "function" ? this.on_data(o["data"]) : void 0;
          case "DISCONNECT":
            return typeof this.on_disconnect === "function" ? this.on_disconnect() : void 0;
        }
      };

      return WebSocketBridge;

    })();

    return socket;

  })();

  History = (function() {
    function History(max_length, none) {
      this.max_length = max_length != null ? max_length : 50;
      this.none = none != null ? none : "";
      this.index = -1;
      this.mem = [];
    }

    History.prototype.length = function() {
      return this.mem.length;
    };

    History.prototype.get = function() {
      if (this.length() > 0 && this.index >= 0) {
        return this.mem[this.index];
      } else {
        return this.none;
      }
    };

    History.prototype.up = function() {
      this.index = Math.min(this.index + 1, this.length() - 1);
      return this.get();
    };

    History.prototype.down = function() {
      this.index = Math.max(this.index - 1, -1);
      return this.get();
    };

    History.prototype.add = function(msg) {
      if (!(indexOf.call(this.mem, msg) >= 0)) {
        if (this.mem.unshift(msg) > this.max_length) {
          return this.mem.pop();
        }
      } else {
        this.mem = this.mem.filter(function(m) {
          return m !== msg;
        });
        return this.add(msg);
      }
    };

    History.prototype.reset = function() {
      return this.index = -1;
    };

    return History;

  })();

  Autocomplete = (function() {
    function Autocomplete(words1) {
      this.words = words1 != null ? words1 : [];
      this.words.sort();
    }

    Autocomplete.prototype.add = function(word) {
      if (!(indexOf.call(this.words, word) >= 0)) {
        this.words.push(word);
        return this.words.sort();
      }
    };

    Autocomplete.prototype.remove = function(word) {
      return this.words = this.words.filter(function(w) {
        return w !== word;
      });
    };

    Autocomplete.prototype.filter = function(msg) {
      var word;
      word = msg.split(" ").pop();
      return this.words.filter(function(w) {
        return w.indexOf(word) === 0 && w !== word;
      });
    };

    Autocomplete.prototype.common = function(words) {
      return words.reduce(function(c, w) {
        var i, l, ref, rw;
        rw = "";
        for (i = l = 0, ref = Math.min(c.length, w.length); 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          if (c[i] === w[i]) {
            rw += c[i];
          } else {
            return rw;
          }
        }
        return rw;
      });
    };

    Autocomplete.prototype.cut = function(msg, word) {
      return word.slice(msg.split(" ").pop().length);
    };

    return Autocomplete;

  })();

  intro = "<span class='color-text'>\n<pre class='color-system'>\n┌┬┐   ┌─┐┬ ┬┌─┐┌┬┐  ┬  ┌─┐┌─┐┌─┐┬   ┬ ┬┌─┐┌┐\n ││───│  ├─┤├─┤ │───│  │ ││  ├─┤│───│││├┤ ├┴┐\n─┴┘   └─┘┴ ┴┴ ┴ ┴   ┴─┘└─┘└─┘┴ ┴┴─┘ └┴┘└─┘└─┘\n</pre>\n<br>\n    Welcome to\n    <span class='color-whisper'>d-chat-local-web</span>\n    — fully (almost) client-side\n    <span class='color-error'>ru</span><span class='color-system'>battle.net</span>\n    chat client.\n    <br>\n    For more information type '<span class='color-error'>\\help</span>'\n    or press <span class='color-error'>f1</span>.\n<br><br>\nVersion: 0.1.0<br>\nFeature requests and issues are welcome at\n<a href=\"https://github.com/pohmelie/d-chat-local-web\" target=\"_blank\">d-chat-local-web</a>\n</span>";

  Autotrade = (function() {
    function Autotrade(say, msg1, activity, timeout) {
      this.say = say;
      this.msg = msg1 != null ? msg1 : "N enigma free PLZ PLZ!!";
      this.activity = activity != null ? activity : 10;
      this.timeout = timeout != null ? timeout : 300;
      this.timer = bind(this.timer, this);
      this.running = false;
      this.current_time = 0;
      this.current_activity = 0;
    }

    Autotrade.prototype.timer = function() {
      if (this.running) {
        if (this.msg === "") {
          this.stop();
          return;
        }
        if (this.current_time === this.timeout - 1) {
          if (this.current_activity >= this.activity) {
            this.current_time = 0;
            this.current_activity = 0;
            this.say(this.msg);
          }
        } else {
          this.current_time += 1;
        }
        return setTimeout(this.timer, 1000);
      }
    };

    Autotrade.prototype.trigger_activity = function() {
      return this.current_activity = Math.min(this.current_activity + 1, this.activity);
    };

    Autotrade.prototype.start = function() {
      this.current_time = 0;
      this.running = true;
      this.current_activity = 0;
      return setTimeout(this.timer, 1000);
    };

    Autotrade.prototype.stop = function() {
      return this.running = false;
    };

    return Autotrade;

  })();

  Calculator = (function() {
    function Calculator() {}

    Calculator.runes = ["pul", "um", "mal", "ist", "gul", "vex", "ohm", "lo", "sur", "ber", "jah"];

    Calculator.per_train = (16 + 8 + 4 + 2 + 1) * 7 / 11;

    Calculator.pp = function(stack, highest) {
      var n, puls_per_rune, result;
      if (highest == null) {
        highest = "jah";
      }
      result = [];
      n = Calculator.runes.indexOf(highest);
      while (stack !== 0) {
        puls_per_rune = bit32.shl(1, n);
        if (stack >= puls_per_rune) {
          result.push((Math.floor(stack / puls_per_rune)) + " " + Calculator.runes[n]);
          stack %= puls_per_rune;
        }
        n -= 1;
      }
      if (result.length === 0) {
        return "stack is empty.";
      } else {
        return result.join(", ");
      }
    };

    Calculator.calc = function(words) {
      var count, i, p, ref, ref1, result, stack;
      words = words.map(function(w) {
        return w.toLowerCase();
      }).filter(function(w) {
        return w !== "";
      });
      count = 1;
      stack = 0;
      result = [];
      i = 0;
      while (i < words.length) {
        switch (words[i]) {
          case "to":
            i += 1;
            if ((i < words.length) && (ref = words[i], indexOf.call(Calculator.runes, ref) >= 0)) {
              result.push(Calculator.pp(stack, words[i]));
            } else {
              return result.join("\n");
            }
            break;
          case "t":
            result.push("Trains count: " + (Math.ceil(stack / Calculator.per_train)));
            break;
          case "c":
            stack = 0;
            break;
          case "p":
            result.push(Calculator.pp(stack));
            break;
          default:
            if (isNaN(parseInt(words[i])) || (words[i][words[i].length - 1] === "%")) {
              if (ref1 = words[i], indexOf.call(Calculator.runes, ref1) >= 0) {
                stack += count * bit32.shl(1, Calculator.runes.indexOf(words[i]));
                count = 1;
              } else if (words[i][words[i].length - 1] === "%") {
                p = words[i].slice(0, words[i].length - 1);
                if (isNaN(parseInt(p))) {
                  return result.join("\n");
                } else {
                  p = parseInt(p);
                  result.push(p + "% of stack = " + (Calculator.pp(Math.round(stack * p / 100))));
                }
              }
            } else {
              count = parseInt(words[i]);
            }
        }
        i += 1;
      }
      result.push("Stack: " + Calculator.pp(stack));
      return result.join("\n");
    };

    return Calculator;

  })();

  help_message = function(delimiter) {
    return "d-chat-local-web help information.\nCommands:\n\n    " + delimiter + "echo message\n        Print message to screen without sending to battle.net.\n\n    " + delimiter + "connect account password\n        Disconnect if connected and connect to battle.net.\n\n    " + delimiter + "disconnect\n        Disconnect from battle.net.\n\n    " + delimiter + "reload\n        Reloads 'init' file. 'init' file loads on start and simply executes like user input.\n\n    " + delimiter + "autoscroll\n        Switch autoscroll on/off. Default 'on'.\n\n    " + delimiter + "help\n        Show help information.\n\n    " + delimiter + "tab-mode\n        Switch tab-mode on/off. Default 'on'.\n\n    " + delimiter + "autotrade-message message\n    " + delimiter + "atm message\n        Set autotrade message.\n\n    " + delimiter + "autotrade-timeout timeout\n        Set autotrade timeout in seconds. Default 300.\n\n    " + delimiter + "autotrade-activity count\n        Set autotrade use-activity value. When use-activity mode is on, autotrade message won't appear before 'count' messages. This is good for 'not to spam' and 'be quiet'. Default 10.\n\n    " + delimiter + "autotrade-start\n        Start autotrade loop.\n\n    " + delimiter + "autotrade-stop\n        Stop autotrade loop.\n\n    " + delimiter + "autotrade-info\n        Show current state of autotrade.\n\n    " + delimiter + "calc actions\n        Stack oriented rune calculator without memory. 'actions' — space-separated sequence of commands. Available commands:\n\n            count {'pul', ..., 'jah'}\n                Put 'count' (1 if omitted) runes on stack. You can only use runes from 'pul' to 'jah'.\n\n            p\n                Print stack with \"highest\" rune 'jah'.\n\n            to {'pul', ..., 'jah'}\n                Print stack with specified \"highest\" rune.\n\n            c\n                Clear stack.\n\n            t\n                Show stack size in \"trains\" (7 mules average hellforge rune drop).\n\n            count'%'\n                Print 'count' percents of stack.\n\n        Example:\n\n            Input:\n                " + delimiter + "calc 15 pul um p -1 pul p to ist 25% t c t\n\n            Output:\n                1 gul, 1 pul\n                1 gul\n                2 ist\n                25% of stack = 1 mal\n                Trains count: 1\n                Trains count: 0\n                Stack: stack is empty.\n\n    " + delimiter + "clear-local-storage\n        Erase local options.\n\n    " + delimiter + "clear-screen\n        Clear main tab.\n\n\nShortcuts:\n\n    ctrl + right/left\n        Switch to next/previous tab.\n\n    ctrl + w\n        Close current tab.\n\n    ctrl + s\n        Switch autotrade on/off.\n\n    ctrl + r\n        Same as '" + delimiter + "reload'.\n\n    ctrl + d\n        Same as '" + delimiter + "disconnect'.\n\n    ctrl + i\n        Same as '" + delimiter + "autotrade-info'.\n\n    ctrl + m\n        Switch to main tab.\n\n    up/down\n        Browse commands history.\n\n    tab\n        Request autocomplete. Autocompletes if there is one possibility, prints all possibilities else.";
  };

  Dchat = (function() {
    function Dchat(tabs_id, chat_id, user_list_id, input_id, commands_prefix) {
      this.tabs_id = tabs_id;
      this.chat_id = chat_id;
      this.user_list_id = user_list_id;
      this.input_id = input_id;
      this.commands_prefix = commands_prefix != null ? commands_prefix : "\\";
      this.load_init_file = bind(this.load_init_file, this);
      this.input_key = bind(this.input_key, this);
      this.common_message = bind(this.common_message, this);
      this.global_key = bind(this.global_key, this);
      this.chat_event = bind(this.chat_event, this);
      this.refresh_title = bind(this.refresh_title, this);
      this.disconnect = bind(this.disconnect, this);
      this.connect = bind(this.connect, this);
      this.socket_error = bind(this.socket_error, this);
      this.login_error = bind(this.login_error, this);
      this.render_phrases = bind(this.render_phrases, this);
      this.reconnect_on_disconnection = bind(this.reconnect_on_disconnection, this);
      this.max_symbols = 199;
      this.min_autotrade_timeout = 120;
      this.min_autotrade_activity = 0;
      this.default_autotrade_timeout = 300;
      this.default_autotrade_activity = 10;
      this.nicknames = {};
      this.users_count = 0;
      this.channel = null;
      this.connected = false;
      if (localStorage.hashed_password != null) {
        try {
          this.hashed_password = JSON.parse(localStorage.hashed_password);
        } catch (_error) {
          localStorage.clear();
        }
      }
      this.autoscroll = localStorage.autoscroll || true;
      this.account = localStorage.account;
      this.tab_mode = localStorage.tab_mode || true;
      this.replacing_symbols = {
        ">": "&gt;",
        "<": "&lt;",
        " ": "&nbsp;<wbr>",
        "\n": "<br>"
      };
      this.commands_list = ["echo", "connect", "disconnect", "reload", "autoscroll", "help", "tab-mode", "autotrade-message", "atm", "autotrade-timeout", "autotrade-activity", "autotrade-start", "autotrade-stop", "autotrade-info", "calc", "clear-local-storage", "clear-screen"];
      this.autocomplete = new Autocomplete(this.commands_list.map((function(_this) {
        return function(c) {
          return _this.commands_prefix + c;
        };
      })(this)));
      if (isNaN(localStorage.autotrade_activity) || (localStorage.autotrade_activity < this.min_autotrade_activity)) {
        localStorage.autotrade_activity = this.default_autotrade_activity;
      }
      if (isNaN(localStorage.autotrade_timeout) || (localStorage.autotrade_timeout < this.min_autotrade_timeout)) {
        localStorage.autotrade_timeout = this.default_autotrade_timeout;
      }
      this.autotrade = new Autotrade(this.common_message, localStorage.autotrade_msg || "N enigma free PLZ PLZ!!", localStorage.autotrade_activity, localStorage.autotrade_timeout);
      this.history = new History();
      this.tabs = new ui.Tabs(this.tabs_id, this.chat_id, this.user_list_id, this.input_id, this.render_phrases, this.refresh_title);
      this.tabs.set_active(this.tabs.main);
      this.websocket = new socket.WebSocketBridge();
      this.bn = new bnet.Bnet("rubattle.net", 6112, this.websocket.connect, this.websocket.send, this.login_error, this.chat_event);
      this.websocket.on_data = this.bn.on_packet;
      this.websocket.on_error = this.socket_error;
      this.websocket.on_disconnect = this.reconnect_on_disconnection;
      $(this.input_id).on("keydown", this.input_key);
      $(window).on("keydown", this.global_key);
      this.refresh_title();
      this.show_intro();
      if ((this.account != null) && (this.hashed_password != null)) {
        this.command("connect");
      }
      if (localStorage.autotrade === "true") {
        this.command("autotrade-start");
      }
    }

    Dchat.prototype.reconnect_on_disconnection = function() {
      if (this.connected) {
        return this.command("connect");
      } else {
        return this.disconnect();
      }
    };

    Dchat.prototype.render_phrases = function() {
      var color, html, l, len, msg, phrase, phrases, raw;
      phrases = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      html = "";
      for (l = 0, len = phrases.length; l < len; l++) {
        phrase = phrases[l];
        if (typeof phrase !== "object") {
          phrase = ["color-text", phrase];
        }
        color = phrase[0], msg = phrase[1], raw = phrase[2];
        if (raw !== true) {
          msg = this.prepare_string(msg);
        }
        html += "<span class='" + color + "'>" + msg + "</span>";
      }
      return html;
    };

    Dchat.prototype.echo = function() {
      var phrases;
      phrases = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.tabs.echo("<div>" + (this.render_phrases.apply(this, [['color-time', this.time()]].concat(phrases))) + "</div>", this.autoscroll);
    };

    Dchat.prototype.whisper = function() {
      var phrases, username;
      username = arguments[0], phrases = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return this.tabs.whisper(username, "<div>" + (this.render_phrases.apply(this, [['color-time', this.time()]].concat(phrases))) + "</div>", this.autoscroll);
    };

    Dchat.prototype.login_error = function(stage, reason) {
      var reasons;
      reasons = ["Account doesn't exists", "Wrong password"];
      if (reasons[reason - 1] != null) {
        this.echo(["color-error", "Login failed. " + reasons[reason - 1] + "."]);
      } else {
        this.echo(["color-error", "Login failed. (stage = " + stage + ", reason = " + reason + ")."]);
      }
      return this.disconnect();
    };

    Dchat.prototype.socket_error = function(msg) {
      this.echo(["color-error", "socket error: " + msg]);
      return this.disconnect();
    };

    Dchat.prototype.connect = function(acc, pass, hashed) {
      if (hashed == null) {
        hashed = false;
      }
      this.disconnect();
      if (this.websocket.websocket_ok) {
        this.command("echo Connecting...");
        this.bn.login(acc, pass, hashed);
        return this.connected = true;
      } else {
        this.websocket.reset();
        return setTimeout(((function(_this) {
          return function() {
            return _this.connect(acc, pass, hashed);
          };
        })(this)), 1000);
      }
    };

    Dchat.prototype.disconnect = function() {
      var k, ref, v;
      if (this.connected) {
        this.connected = false;
        this.websocket.disconnect();
        this.command("echo Disconnected.");
        this.users_count = 0;
        this.channel = null;
        this.refresh_title();
        this.tabs.user_list.clear();
        ref = this.nicknames;
        for (k in ref) {
          v = ref[k];
          this.autocomplete.remove("*" + k);
        }
        return this.nicknames = {};
      }
    };

    Dchat.prototype.refresh_title = function() {
      var title, total_unread;
      if (this.connected) {
        total_unread = this.tabs.tabs.reduce((function(u, t) {
          return u + t.unread;
        }), 0);
        if (total_unread !== 0) {
          title = "[" + total_unread + "] " + this.channel + " (" + this.users_count + ")";
        } else {
          title = this.channel + " (" + this.users_count + ")";
        }
      } else {
        title = "d-chat-local-web";
      }
      this.tabs.main.set_title(title);
      return $(document).attr("title", title);
    };

    Dchat.prototype.time = function() {
      var d, s;
      d = new Date();
      s = [d.getHours(), d.getMinutes(), d.getSeconds()].map(function(x) {
        if (x < 10) {
          return "0" + x.toString();
        } else {
          return x.toString();
        }
      }).join(":");
      return "[" + s + "] ";
    };

    Dchat.prototype.chat_event = function(pack) {
      var k, nickname, ref, s, v;
      switch (pack.event_id) {
        case "ID_USER":
        case "ID_JOIN":
        case "ID_USERFLAGS":
          nickname = "";
          if (pack.text.substring(0, 4) === "PX2D") {
            s = pack.text.split(",");
            if (s.length > 1) {
              nickname = s[1];
            }
          }
          if (this.nicknames[pack.username] == null) {
            this.users_count += 1;
          }
          this.nicknames[pack.username] = nickname;
          this.autocomplete.add("*" + pack.username);
          this.tabs.user_list.add(pack.username, nickname);
          return this.refresh_title();
        case "ID_LEAVE":
          delete this.nicknames[pack.username];
          this.autocomplete.remove("*" + pack.username);
          this.tabs.user_list.remove(pack.username);
          this.users_count -= 1;
          return this.refresh_title();
        case "ID_INFO":
          return this.echo(["color-system", pack.text]);
        case "ID_ERROR":
          return this.echo(["color-error", pack.text]);
        case "ID_TALK":
        case "ID_EMOTE":
          this.echo(["color-nickname", this.nicknames[pack.username]], ["color-delimiter", "*"], ["color-nickname", pack.username], ["color-delimiter", ": "], ["color-text", pack.text]);
          return this.autotrade.trigger_activity();
        case "ID_CHANNEL":
          this.channel = pack.text;
          this.users_count = 0;
          ref = this.nicknames;
          for (k in ref) {
            v = ref[k];
            this.autocomplete.remove("*" + k);
          }
          this.nicknames = {};
          this.tabs.user_list.clear();
          return this.refresh_title();
        case "ID_WHISPER":
          if (this.tab_mode) {
            return this.whisper("*" + pack.username, ["color-nickname", this.nicknames[pack.username] || ""], ["color-delimiter", "*"], ["color-nickname", pack.username], ["color-delimiter", ": "], ["color-text", pack.text]);
          } else {
            return this.echo(["color-whisper-nickname", (this.nicknames[pack.username] || "") + ("*" + pack.username)], ["color-delimiter", " -> "], ["color-whisper-nickname", "*" + this.account], ["color-delimiter", ": "], ["color-whisper", pack.text]);
          }
          break;
        case "ID_WHISPERSENT":
          if (this.tab_mode) {
            this.whisper("*" + pack.username, ["color-delimiter", "*"], ["color-nickname", this.account], ["color-delimiter", ": "], ["color-text", pack.text]);
            return this.tabs.set_active(this.tabs.get_tab("*" + pack.username));
          } else {
            return this.echo(["color-whisper-nickname", "*" + this.account], ["color-delimiter", " -> "], ["color-whisper-nickname", (this.nicknames[pack.username] || "") + ("*" + pack.username)], ["color-delimiter", ": "], ["color-whisper", pack.text]);
          }
          break;
        case "ID_BROADCAST":
          return this.echo(["color-whisper-nickname", pack.username], ["color-delimiter", ": "], ["color-whisper", pack.text]);
      }
    };

    Dchat.prototype.global_key = function(e) {
      if (e.ctrlKey) {
        switch (e.which) {
          case 39:
            this.tabs.next();
            return e.preventDefault();
          case 37:
            this.tabs.prev();
            return e.preventDefault();
          case 87:
            this.tabs.remove();
            return e.preventDefault();
          case 83:
            this.toggle_autotrade();
            return e.preventDefault();
          case 82:
            this.load_init_file();
            return e.preventDefault();
          case 68:
            this.disconnect();
            return e.preventDefault();
          case 77:
            this.tabs.set_active();
            return e.preventDefault();
          case 73:
            this.command("autotrade-info");
            return e.preventDefault();
        }
      } else if (e.which === 112) {
        this.show_help();
        return e.preventDefault();
      }
    };

    Dchat.prototype.toggle_autotrade = function() {
      if (this.autotrade.running) {
        return this.command("autotrade-stop");
      } else {
        return this.command("autotrade-start");
      }
    };

    Dchat.prototype.toggle_autoscroll = function() {
      this.autoscroll = !this.autoscroll;
      return this.command("echo Autoscroll set to " + this.autoscroll + ".");
    };

    Dchat.prototype.common_message = function(msg) {
      var smsg;
      if (msg !== "") {
        if (msg[0] === this.commands_prefix) {
          return this.command(msg.substring(1));
        } else if (this.connected && (this.channel != null)) {
          smsg = msg;
          while (smsg !== "") {
            this.bn.say(smsg.substr(0, this.max_symbols));
            smsg = smsg.substr(this.max_symbols);
          }
          if (msg[0] !== "/") {
            return this.echo(["color-delimiter", "*"], ["color-nickname", this.account], ["color-delimiter", ": "], ["color-text", msg]);
          }
        }
      }
    };

    Dchat.prototype.input_key = function(e) {
      var common, msg, words;
      switch (e.which) {
        case 13:
          this.history.add($(this.input_id).val());
          this.history.reset();
          msg = this.tabs.active.prefix + $(this.input_id).val().trim();
          $(this.input_id).val("");
          return this.common_message(msg);
        case 9:
          if (!e.ctrlKey) {
            msg = $(this.input_id).val();
            words = this.autocomplete.filter(msg);
            if (words.length === 1) {
              $(this.input_id).val(msg + this.autocomplete.cut(msg, words[0]));
            } else if (words.length > 1) {
              common = this.autocomplete.cut(msg, this.autocomplete.common(words));
              $(this.input_id).val(msg + common);
              if (common.length === 0) {
                words.unshift(words.length + " possibilities:");
                this.echo(["color-autocomplete", words.join("\n")]);
              }
            }
            return e.preventDefault();
          }
          break;
        case 38:
          if (this.history.length() > 0) {
            $(this.input_id).val(this.history.up());
          }
          return e.preventDefault();
        case 40:
          if (this.history.length() > 0) {
            $(this.input_id).val(this.history.down());
          }
          return e.preventDefault();
      }
    };

    Dchat.prototype.command = function(cmd) {
      var acc, pass, ref, t;
      cmd = cmd.split(" ");
      switch (cmd[0].toLowerCase()) {
        case "echo":
          if (cmd.length > 1) {
            return this.echo(["color-echo", cmd.slice(1).join(" ")]);
          }
          break;
        case "connect":
          ref = cmd.slice(1).filter(function(x) {
            return x !== "";
          }), acc = ref[0], pass = ref[1];
          if ((acc != null) && (pass != null)) {
            this.connect(acc, pass);
            if (this.bn.hashpass != null) {
              localStorage.hashed_password = JSON.stringify(this.bn.hashpass);
              return localStorage.account = this.account = acc;
            }
          } else if ((localStorage.account != null) && (localStorage.hashed_password != null)) {
            this.account = localStorage.account;
            return this.connect(localStorage.account, JSON.parse(localStorage.hashed_password), true);
          } else {
            return this.command("echo Can't connect without account name and password. Type '" + this.commands_prefix + "help' for more information.");
          }
          break;
        case "disconnect":
          return this.disconnect();
        case "reload":
          return this.load_init_file();
        case "autoscroll":
          return this.toggle_autoscroll();
        case "help":
          return this.show_help();
        case "tab-mode":
          return this.toggle_tab_mode();
        case "autotrade-message":
        case "atm":
          if (cmd.length > 1) {
            localStorage.autotrade_msg = this.autotrade.msg = cmd.slice(1).join(" ");
          }
          return this.command("echo Current autotrade message is '" + this.autotrade.msg + "'.");
        case "autotrade-timeout":
          if (cmd.length > 1) {
            t = parseInt(cmd[1]);
            if (isNaN(t) || t < this.min_autotrade_timeout) {
              this.command("echo Bad number '" + cmd[1] + "' (must be greater or equal to " + this.min_autotrade_timeout + ").");
            } else {
              localStorage.autotrade_timeout = this.autotrade.timeout = t;
            }
          }
          return this.command("echo Current autotrade timeout is '" + this.autotrade.timeout + "'.");
        case "autotrade-activity":
          if (cmd.length > 1) {
            t = parseInt(cmd[1]);
            if (isNaN(t) || t < this.min_autotrade_activity) {
              this.command("echo Bad number '" + cmd[1] + "' (must be greater or equal to " + this.min_autotrade_activity + ").");
            } else {
              localStorage.autotrade_activity = this.autotrade.activity = t;
            }
          }
          return this.command("echo Current autotrade activity is '" + this.autotrade.activity + "'.");
        case "autotrade-start":
          this.command("echo Autotrade started with message = '" + this.autotrade.msg + "' and timeout = '" + this.autotrade.timeout + "'.");
          this.autotrade.start();
          return localStorage.autotrade = true;
        case "autotrade-stop":
          this.command("echo Autotrade stopped.");
          this.autotrade.stop();
          return localStorage.autotrade = false;
        case "autotrade-info":
          return this.command("echo Autotrade info:\nrunning = " + this.autotrade.running + "\nmessage = " + this.autotrade.msg + "\ntime = " + this.autotrade.current_time + "/" + this.autotrade.timeout + "\nactivity = " + this.autotrade.activity + "\ncurrent activity = " + this.autotrade.current_activity);
        case "calc":
          return this.command("echo " + (Calculator.calc(cmd.slice(1))));
        case "clear-local-storage":
          localStorage.clear();
          return this.command("echo Local storage erased.");
        case "clear-screen":
          this.tabs.main.clear();
          return this.tabs.set_active();
        default:
          return this.command("echo Unknown command '" + (cmd[0].toLowerCase()) + "'.");
      }
    };

    Dchat.prototype.toggle_tab_mode = function() {
      this.tab_mode = !this.tab_mode;
      this.command("echo Tab mode set to " + this.tab_mode + ".");
      if (!this.tab_mode) {
        this.tabs.tabs.filter(function(t) {
          return t.closeable;
        }).forEach(this.tabs.remove);
        return this.refresh_title();
      }
    };

    Dchat.prototype.load_init_file = function(data) {
      if (data != null) {
        return data.split("\n").map(function(x) {
          return x.trim();
        }).forEach(this.common_message);
      } else {
        return $.get("init", this.load_init_file, "text").error((function(_this) {
          return function() {
            return _this.command("echo Initialization file 'init' missing.");
          };
        })(this));
      }
    };

    Dchat.prototype.show_help = function() {
      return this.command("echo " + (help_message(this.commands_prefix)));
    };

    Dchat.prototype.prepare_string = function(str) {
      var find, ref, replace;
      ref = this.replacing_symbols;
      for (find in ref) {
        replace = ref[find];
        str = str.replace(new RegExp(find, 'g'), replace);
      }
      return str;
    };

    Dchat.prototype.show_intro = function() {
      return this.echo(["color-text", intro, true]);
    };

    return Dchat;

  })();

  init = function() {
    var dchat;
    return dchat = new Dchat("#tabs", "#chat", "#user-list", "#input");
  };

  $(init);

}).call(this);
